/**
 * Copyright (C) 2016 Raymond L. Rivera <ray.l.rivera@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package ray.rage.rendersystem.shader;

import java.util.*;

import ray.rage.common.*;
import ray.rage.rendersystem.*;
import ray.rage.scene.*;
import ray.rml.*;

/**
 * A <i>GPU shader program</i> represents the modern <i>programmable</i>
 * graphics pipeline.
 * <p>
 * The modern shader-based pipeline is made of several programmable stages, some
 * of which are required and some of which are optional. The minimum number of
 * <i>required</i> stages are made of vertex and fragment programs, generally
 * written in
 * <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a>,
 * which are compiled and linked (i.e. {@link #build() built}) into a single
 * object program that gets executed directly in the
 * <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPU</a>.
 * GPUs are often referred to as the "servers" while the applications running on
 * the CPU are often referred to as "clients".
 * <p>
 * Other than providing the source code for specific stages and basic setup,
 * clients are not generally expected to work with shaders directly.
 *
 * @author Raymond L. Rivera
 *
 */
public interface GpuShaderProgram extends Disposable {

    /**
     * Used to determine which {@link GpuShaderProgram program} will be created.
     * <p>
     * It's a way to request an implementation that fulfills a specific purpose
     * or role. Currently, only rendering objects, skyboxes, skeletal rendering,
     * and tessellations are supported.
     *
     * @author Raymond L. Rivera
     *
     */
    // FIXME: Should find a way to remove this and avoid creating the programs
    // this way
    enum Type {
        RENDERING,

        SKYBOX,

        SKELETAL_RENDERING,

        TESSELLATION, 
        
        DEPTH, 
        
        ITEM_BOX,
        
        FRAMEBUFFER,
        
        TRANSPARENT,
        
        GUI,
        
        GUI_BACKGROUND,
    }

    /**
     * The <i>stage</i> within the graphics pipeline that source code will be
     * added for. Currently, clients can only add code for vertex, fragment,
     * control, and evaluation shader stages.
     *
     * @author Raymond L. Rivera
     *
     */
    enum Stage {
        VERTEX_PROGRAM,

        CONTROL_PROGRAM,    // For Tessellation
        
        EVALUATION_PROGRAM, // For Tessellation

        FRAGMENT_PROGRAM
    }

    /**
     * An <i>input</i> expected by the {@link GpuShaderProgram program} from
     * clients.
     *
     * @author Raymond L. Rivera
     *
     */
    interface Input<T> extends Managed<GpuShaderProgram>, Disposable {

        /**
         * Sets <code>this</code> {@link GpuShaderProgram.Input input's} value.
         *
         * @param v
         *            The value.
         */
        void set(T v);
    }

    /**
     * A <i>{@link Nameable nameable}</i> {@link GpuShaderProgram.Input input}
     * in the source code that is given a <i>location</i> ID at runtime by the
     * underlying driver.
     * <p>
     * This is not to be confused with the {@link StorageBuffer#getBufferId()}
     *
     * @author Raymond L. Rivera
     *
     */
    interface LocatableInput<T> extends Input<T>, Nameable {

        /**
         * Gets the shader location ID generated by the underlying driver for
         * the {@link GpuShaderProgram program} to uniquely identify
         * <code>this</code> {@link GpuShaderProgram.Input input}.
         *
         * @return The ID of <code>this</code>
         *         {@link GpuShaderProgram.LocatableInput input}.
         */
        int getLocationId();

    }

    /**
     * A <i>dynamic storage buffer</i> for {@link GpuShaderProgram.Input input}
     * data that receives a buffer ID at runtime by the underlying driver.
     *
     * @author Raymond L. Rivera
     *
     */
    interface StorageBuffer<T> extends Input<T> {

        /**
         * Gets the ID generated by the underlying driver for the
         * {@link GpuShaderProgram program} to uniquely identify
         * <code>this</code> {@link GpuShaderProgram.StorageBuffer buffer}.
         *
         * @return The ID of <code>this</code>
         *         {@link GpuShaderProgram.StorageBuffer buffer}.
         */
        int getBufferId();

    }

    /**
     * An {@link GpuShaderProgram.Input input} <i>attribute</i>.
     * <p>
     * Attributes represent {@link GpuShaderProgram.LocatableInput localized}
     * data that can <i>change</i> in GPU memory
     * {@link GpuShaderProgram.StorageBuffer buffers} between different
     * {@link GpuShaderProgram.Stage stages} within a single rendering
     * invocation.
     *
     * @author Raymond L. Rivera
     *
     */
    interface Attribute<T> extends StorageBuffer<T>, LocatableInput<T> {

        /**
         * {@inheritDoc}
         *
         * In this case, it's the name of the {@link GpuShaderProgram.Attribute
         * attribute}, as specified in the shader's source code.
         *
         * @return The name of <code>this</code>
         *         {@link GpuShaderProgram.Attribute attribute}.
         */
        @Override
        String getName();

    }

    /**
     * An {@link GpuShaderProgram.Input input} <i>uniform</i>.
     * <p>
     * Uniforms represent {@link GpuShaderProgram.LocatableInput localized} data
     * that remains <i>constant</i> in GPU memory between different
     * {@link GpuShaderProgram.Stage stages} within a single rendering
     * invocation.
     *
     * @author Raymond L. Rivera
     *
     */
    interface Uniform<T> extends LocatableInput<T> {

        /**
         * {@inheritDoc}
         *
         * In this case, it's the name of the {@link GpuShaderProgram.Uniform
         * uniform}, as specified in the shader's source code.
         *
         * @return The name of <code>this</code> {@link GpuShaderProgram.Uniform
         *         uniform}.
         */
        @Override
        String getName();

    }

    /**
     * The <i>context</i> encapsulates all the objects whose information is
     * needed by the {@link GpuShaderProgram program} to execute properly.
     * <p>
     * This is basically a data container for {@link GpuShaderProgram program}
     * arguments. However, it does so in away that avoids polluting the
     * {@link GpuShaderProgram program} interface.
     *
     * @author Raymond L. Rivera
     *
     */
    interface Context extends Disposable {

        /**
         * Sets the {@link Renderable renderable}.
         *
         * @param r
         *            The {@link Renderable renderable}.
         * @throws NullPointerException
         *             If the {@link Renderable renderable} is
         *             <code>null</code>. It's required.
         */
        void setRenderable(Renderable r);

        /**
         * Gets the {@link Renderable renderable}.
         *
         * @return The {@link Renderable renderable}.
         */
        Renderable getRenderable();

        /**
         * Sets the viewing transform {@link Matrix matrix}.
         *
         * @param vm
         *            The view {@link Matrix matrix}.
         * @throws NullPointerException
         *             If the {@link Matrix matrix} is <code>null</code>. It's
         *             required.
         */
        void setViewMatrix(Matrix4 vm);

        /**
         * Gets the viewing transform {@link Matrix matrix}.
         *
         * @return The view {@link Matrix matrix}.
         */
        Matrix4 getViewMatrix();

        /**
         * Sets the projection {@link Matrix matrix}.
         *
         * @param pm
         *            The projection {@link Matrix matrix}.
         * @throws NullPointerException
         *             If the {@link Matrix matrix} is <code>null</code>. It's
         *             required.
         */
        void setProjectionMatrix(Matrix4 pm);

        /**
         * Gets the projection {@link Matrix matrix}.
         *
         * @return The projection {@link Matrix matrix}.
         */
        Matrix4 getProjectionMatrix();

        /**
         * Sets the global {@link AmbientLight ambient-light}.
         *
         * @param ambientLight
         *            The {@link AmbientLight ambient-light}.
         */
        void setAmbientLight(AmbientLight ambientLight);

        /**
         * Gets the {@link AmbientLight ambient-light}.
         *
         * @return The {@link AmbientLight ambient-light}, if set. Otherwise
         *         <code>null</code>. It's optional.
         */
        AmbientLight getAmbientLight();

        /**
         * Sets the {@link Light light} source to use.
         *
         * @param lights
         *            The {@link Light light} source.
         */
        void setLightsList(List<Light> lights);

        /**
         * Gets the {@link Light light} source.
         *
         * @return The {@link Light light} source, if set. Otherwise
         *         <code>null</code>. It's optional.
         */
        List<Light> getLightsList();
        
        void setLightSpaceMatrix(Matrix4 lightSpace);
        
        Matrix4 getLightSpaceMatrix();

		Vector3 getViewPos();
		Vector3 getLightPos();
		
		void setViewPos(Vector3 viewPos);
		void setLightPos(Vector3 lightPos);

		void setCanReceiveShadows(boolean b);

		Boolean getCanReceiveShadows();
    }

    /**
     * Gets the ID generated by the underlying driver for <code>this</code>
     * {@link GpuShaderProgram program}.
     *
     * @return The ID of <code>this</code> {@link GpuShaderProgram program}.
     */
    int getId();

    /**
     * The {@link Type type} of <code>this</code> {@link GpuShaderProgram
     * program}.
     *
     * @return The {@link Type type}.
     */
    Type getType();

    /**
     * Creates a new {@link Context context} usable by <code>this</code>
     * {@link GpuShaderProgram program}.
     *
     * @return A new {@link Context context}.
     */
    Context createContext();

    /**
     * Adds the specified source code string for the specified {@link Stage
     * stage}.
     *
     * @param code
     *            The source code to be {@link #build() built} by the underlying
     *            driver implementation.
     * @param stage
     *            The {@link Stage stage} this code is for.
     * @throws IllegalArgumentException
     *             If the code string is empty.
     * @throws NullPointerException
     *             If any of the arguments is <code>null</code>.
     */
    void addSourceCode(String code, Stage stage);

    /**
     * Submits the source code to the driver so that it can get compiled and
     * linked into an executable {@link GpuShaderProgram}.
     *
     * @throws RuntimeException
     *             If the compilation or linking process fails, or if the
     *             {@link GpuShaderProgram program} has been built already.
     * @throws IllegalStateException
     *             If required source code is missing for any of the required
     *             stages.
     * @see #addSourceCode(String, Stage)
     */
    void build();

    /**
     * Binds <code>this</code> {@link GpuShaderProgram program} to make it
     * active.
     * <p>
     * The next {@link Renderable renderable} to be submitted to the pipeline
     * will be processed by <code>this</code> instance. This step must be
     * executed <i>before</i> {@link #fetch(Context) fetching} data.
     */
    void bind();

    /**
     * Gets data from the {@link Context context} and submits it into the
     * pipeline, in preparation for a command to draw the {@link Renderable
     * renderable}.
     * <p>
     * This step must be executed <i>after</i> {@link #bind() binding} data.
     *
     * @param ctx
     *            The {@link Context context}.
     */
    void fetch(Context ctx);

    /**
     * Unbinds <code>this</code> {@link GpuShaderProgram program}.
     * <p>
     * This step should be executed <i>after</i> the {@link GpuShaderProgram
     * program} has completed its execution.
     */
    void unbind();

}
